from __future__ import division  # so that 1/3=0.333 instead of 1/3=0
from psychopy import visual, core, data, event, logging, sound, gui
from psychopy.constants import *  # things like STARTED, FINISHED
from numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray
from numpy.random import random, randint, normal, shuffle
import numpy as np
import os  # handy system and path functions
import string
from itertools import repeat
import csv
import scipy
from scipy import io
from scipy.io import wavfile
import sys
from os import path
import string
import pylab
import random ##2017/2/6

import settings as settings

_thisDir = os.path.dirname(os.path.abspath(__file__))
os.chdir(_thisDir)

## build the auditory surprise file list
x = os.getcwd()
folder = 'surprisesAuditory'
wav_dir = _thisDir + os.sep + folder
wav_names = [x.split(".")[0] for x in os.listdir(wav_dir) if path.isfile(wav_dir+os.sep+x)]
audSS_files = []
for i in range(len(wav_names)):
    audSS_files.append(folder + os.sep + wav_names[i] + '.wav')
    
#Determine SS, SOA, and volume
speed = 0.11 #Duration of stimulus presentation
ISI = 0.00666666666

##This yields 40% distractor intensity attenuation relative to the Probe
vol = 0.99 #This prevents sound from popping.

probeHz = 4000
Tones = [697,760,829,904,944,986,1029,1122,1224,1335,1456,1587,1731,1888,2059,2245,2448,2670,2911]
Pitches = ['low', 'high']
num_complex_sounds = len(Pitches)
components = 5 #How many tones the complex tones are made of.

def frequency(step, base, num_pureTones, num_mixedTones):
    '''
    Returns the list of log-related frequencies.
    'step' = the number of steps between octaves
    'base' = the frequency of middle tone in each mixed tone
    'num_pureTones' = the number of pure tones used for making a mixed tone
    'num_mixedTones' = the number of mixedTones to be generated by this function
    '''
    n_list = []
    for i in range(num_pureTones):
        n_list.append(i-num_pureTones//2) #Use floor division to generate odd numbered lists in which 0 should be centered. E.g. Create [-1, 0, -1] from 0, 1, 2, iteration.
    
    base_list = []
    for i in range(num_mixedTones):
        base_list.append(base*(1.7**i)) #Iterate the exponentials with the root of 2 to create numbers which multiply itself by 2.
    
    a = 2**(1/step)
    res = []
    
    for l in range(len(base_list)):
        for i in range(len(n_list)):
            fn = base_list[l]*((a)**(n_list[i]))
            res.append(int(fn))
        
    return res

targetsHz = frequency(6, 1000, components, num_complex_sounds) #6 semitone steps, 1000 Hz middle frequency.
    
#CLA: Set up auditory stimulus features, and prep the envelope and specified gap (e.g. 6.6667 ms)
sampling_rate = 44100 #in Hz
stim_duration = speed #in seconds
ramp_duration = 0.002 #in seconds
intrastim_duration = stim_duration - 2*ramp_duration #Time between hamming window ramp on and ramp off
interstim_duration = ISI #in seconds, silent time between stimuli
stim_index = np.array(range(int(round(stim_duration / (1/float(sampling_rate)))-1)))
ramp_length = int(ramp_duration / (1/float(sampling_rate)))
intrastim_length = int(intrastim_duration / (1/float(sampling_rate)))
interstim_length = int(interstim_duration / (1/float(sampling_rate)))
ramp_envelope = np.array(range(1,ramp_length+1))/float(ramp_length)
envelope_wave = np.concatenate((ramp_envelope, np.zeros(intrastim_length)+1, 1-ramp_envelope), axis=0)
blank_wave = np.zeros(interstim_length+1) #Small fudge factor to bring total stim length to 4410

amp_array = []
Tones = Tones + [probeHz] #Do this here but not before RAPitems_filename = Tones otherwise, the 4000 will become distractors.
Tones = targetsHz + Tones

Toneitems_array = np.array(Tones) #np.array returns the actual elements of the Tones (e.g. 4000)
SSitems_array = np.array(audSS_files)

#set up tones
toneAmp = []
for i in range(Toneitems_array.size):
    frequency = int(Toneitems_array[i])
    stim_wave = np.sin(2*np.pi*frequency*(stim_index/float(sampling_rate)))
    #Formula for making a sine wave sin(2pi*f)
    if stim_wave.size > envelope_wave.size:
        stim_wave = stim_wave[range(envelope_wave.size)]
    if stim_wave.size < envelope_wave.size:
        stim_wave = np.concatenate(stim_wave, np.zeros(envelope_wave.size - stim_wave.size))
    stim_wave_with_envelope = stim_wave*envelope_wave
    stim_wave_with_envelope_and_blank = np.concatenate((stim_wave_with_envelope, blank_wave), axis=0)
    if i == 0:
        sound_array = np.zeros([Toneitems_array.size + SSitems_array.size + num_complex_sounds, stim_wave_with_envelope_and_blank.size])
    sound_array[i,:] = stim_wave_with_envelope_and_blank
    amp_array.append(np.mean(np.absolute(sound_array[i])))

mean_toneAmp = np.mean(np.absolute(sound_array)) #This is used later for equalizing the amplitude between pure and complex tones.

#Set up letters
SS_amax = []
SS_volume = 1
for i in range(np.size(audSS_files)):
    result = scipy.io.wavfile.read(audSS_files[i])
    if np.size(result[1].shape) == 2:
        stim_wave = (result[1][:,1].astype(float))/32768
    else:
        stim_wave = (result[1].astype(float))/32768
    if stim_wave.size > envelope_wave.size:
        stim_wave = stim_wave[range(envelope_wave.size)]
    if stim_wave.size < envelope_wave.size:
        stim_wave = np.concatenate((stim_wave, np.zeros(envelope_wave.size - stim_wave.size)), axis=0)
    stim_wave_with_envelope = stim_wave*envelope_wave
    stim_wave_with_envelope_and_blank = np.concatenate((stim_wave_with_envelope, blank_wave), axis=0)
    #Result of the below is an array with available tones from 0 to 20, letters from 21 to 40
    sound_array[i+Toneitems_array.size,:] = stim_wave_with_envelope_and_blank
    amp_array.append(np.mean(np.absolute(sound_array[i+Toneitems_array.size])))
    #amp_array is the array of mean summed amplitudes for each item.
    SS_amax.append(np.amax(np.absolute(sound_array[i+Toneitems_array.size])))

mean_SSAmp = np.mean(np.absolute(sound_array[Toneitems_array.size:]))

amax_array = []

for i in range(np.size(amp_array)):
    sound_array[i,:] = sound_array[i,:]*(1/amp_array[i])
    #Multiplying the 1/amp_array values to sound_array so that the means of absolute amplitudes will be equalized.
    amp_array[i] = np.mean(np.absolute(sound_array[i]))
    #This is just to double-check the equalized means of absolute amplitudes.
    amax_array.append(np.amax(np.absolute(sound_array[i])))

#Below are the pre-calibrated values to make the intensities of the target sounds equal to pure tone distractors.
#denominator = intensity of the target, numerator = intensity of the other tones
low_vol = (0.027998900993849666/0.011209202960788102)
high_vol = (0.027998900993849666/0.011216681684048295)

low_target = ((sound_array[0,:] + \
sound_array[1,:] + sound_array[2,:] + sound_array[3,:] + sound_array[4,:])/components)*low_vol
high_target = ((sound_array[5,:] + \
sound_array[6,:] + sound_array[7,:] + sound_array[8,:] + sound_array[9,:])/components)*high_vol

#Here, we are attenuating the volume of distractors.
sound_array = sound_array*vol

#setting up the low mixed tone
sound_array[sound_array.shape[0]-num_complex_sounds,:] = low_target
#setting up the high mixed tone
sound_array[sound_array.shape[0]-(num_complex_sounds-1),:] = high_target
#array.shape[0] returns the number of rows

#The composite tones are assigned to either low, mid, or high variables for the later indexing.
low = sound_array[sound_array.shape[0]-num_complex_sounds,:]
high = sound_array[sound_array.shape[0]-(num_complex_sounds-1),:]

amax_array = []

for i in range(np.size(amp_array)+2):
    #This is just to double-check the equalized means of absolute amplitudes.
    amax_array.append(np.amax(np.absolute(sound_array[i])))

peak_amp = max(amax_array)

#Here we are attenuating the intensity of the sound_array to prevent RAP from popping!
sound_array = sound_array*(1/peak_amp)

amax_array = []

for i in range(np.size(amp_array)+2):
    #This is just to double-check the equalized means of absolute amplitudes.
    amax_array.append(np.amax(np.absolute(sound_array[i])))

peak_amp = max(amax_array)

temp = (Tones + audSS_files + Pitches) #Allows for indexing of sound_array later

#Checking the amp_array of complex tones.
post_amp_array = []
for i in range(len(temp)):
    post_amp_array.append(np.mean(np.absolute(sound_array[i])))

sound_key = list()
for i in range(np.size(temp)):
    sound_key.append(unicode(temp[i]))

print _thisDir

directory = _thisDir + os.sep + 'normalized_wavfiles'

if not os.path.exists(directory):
    os.makedirs(directory)

print sound_key

for i in range(len(sound_key)):
    sound = sound_array[i]
    scaled = np.int16(sound * 32767) # It is not scaled by amax function because it will make the RAP volume uneven.
    scipy.io.wavfile.write(directory + os.sep + str(i) + '.wav', 44100, scaled)
